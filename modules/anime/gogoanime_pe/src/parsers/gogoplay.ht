import '../utils.ht';

class GogoPlay {
    defaultHeaders := {
        'User-Agent': Http.defaultUserAgent,
    };

    cMode := 'cbc';
    cPadding := 'pkcs7';
    cCustomPadding := BytesContainer.fromList(Collection.filledList(8, 8));

    ajaxApiURL := -> baseURL, query {
        return URL.ensureURL('${baseURL}/encrypt-ajax.php?${query}');
    }

    tryGetQuality := -> url {
        for (final x in ['360', '480', '720', '1080'] {
            if (url.contains(x)) return x;
        }

        return 'unknown';
    }

    // Source: (The credit goes to them)
    //  - https://github.com/justfoolingaround/animdl/blob/master/animdl/core/codebase/extractors/gogoplay/__init__.py
    //  - https://github.com/saikou-app/saikou/blob/master/app/src/main/java/ani/saikou/anime/source/extractors/GogoCDN.kt
    parse := -> _url {
        url := URL.ensureURL(_url);
        parsedUrl := URL.parse(url);

        return AsyncTask.resolve(
            () => Http.fetch(
                method: 'get',
                url: url,
                headers: Collection.mergeMap(defaultHeaders, {
                    'Referer': parsedUrl.origin,
                }),
            ),
            onDone: -> resp {
                [_fKeyMatch, _ivMatch] := Regex('container-(\d+)').allMatches(resp.body);
                _fKey := _fKeyMatch?.group(1);
                _sKey := Regex('videocontent-(\d+)').firstMatch(resp.body)?.group(1);
                _iv := _ivMatch?.group(1);
                _dValue := Regex('data-value="([^"]+)"').firstMatch(resp.body)?.group(1);
                if (!_fKey || !_sKey || !_iv || !_dValue) return [];

                fKey := Converter.utf8Encode(_fKey);
                sKey := Converter.utf8Encode(_sKey);
                iv := Converter.utf8Encode(_iv);

                decrypted := cDecrypt(
                    data: Converter.base64Decode(_dValue),
                    key: fKey,
                    iv: iv,
                );

                dQueryParameters := URL.splitQueryString(
                    'id=' + Converter.utf8Decode(decrypted)
                );

                encryptedId := cEncrypt(
                    data: Converter.utf8Encode(dQueryParameters['id']),
                    key: fKey,
                    iv: iv,
                );

                dQueryParameters['alias'] = dQueryParameters['id'];
                dQueryParameters['id'] = Converter.base64Encode(encryptedId);

                return AsyncTask.resolve(
                    () => Http.fetch(
                        method: 'get',
                        url: ajaxApiURL(
                            parsedUrl.origin,
                            URL.joinQueryParameters(dQueryParameters),
                        ),
                        headers: Collection.mergeMap(defaultHeaders, {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Referer': url,
                        }),
                    ),
                    onDone: -> resp {
                        rawParsed := Converter.jsonDecode(resp.body);
                        dData := Converter.utf8Decode(
                            cDecrypt(
                                data: Converter.base64Decode(rawParsed['data']),
                                key: sKey,
                                iv: iv,
                            )
                        ).replaceFirst('o"<P{#meme":', 'e":[{"file":');
                        
                        parsed := Converter.jsonDecode(dData);
                        return AsyncTask.resolveAll(
                            Collection.mapList(
                                Collection.uniqueList(
                                    Collection.mapList(
                                        Collection
                                            .mergeList(parsed['source'], parsed['source_bk']),
                                        (i, x) => x['file'],
                                    ),
                                ),
                                -> i, x {
                                    if (x.contains('.m3u8') {
                                        return () => AsyncTask.resolve(
                                            () => parseM3U8(x),
                                            onDone: -> res {
                                                return Collection.mapList(
                                                    res,
                                                    (i, x) => EpisodeSource(
                                                        url: x,
                                                        headers: defaultHeaders,
                                                        quality: tryGetQuality(x),
                                                        locale: $.defaultLocale,
                                                    ),
                                                );
                                            },
                                        );
                                    }

                                    return () => AsyncTask.value([
                                        EpisodeSource(
                                            url: x,
                                            headers: defaultHeaders,
                                            quality: tryGetQuality(x),
                                            locale: $.defaultLocale,
                                        ),
                                    ]);
                                },
                            ),
                            onDone: (res) => Collection.flattenList(res, 1),
                        );
                    },
                );
            },
        );
    }

    parseM3U8 := -> url {
        return AsyncTask.resolve(
            () => Http.fetch(
                method: 'get',
                url: url,
                headers: Collection.mergeMap(defaultHeaders, {
                    'Referer': url,
                }),
            ),
            onDone: -> resp {
                prevUrl := Regex('(.*?)[^\\/]+$').firstMatch(url).group(1);

                return Collection.mapList(
                    Collection.filterList(
                        resp.body.split('\n'),
                        (i, x) => !x.startsWith('#') && (x.contains('.m3u8') || x.contains('.ts')),
                    ),
                    (i, x) => x.startsWith('http') ? x : '${prevUrl}${x}',
                );
            },
        );
    }

    cDecrypt := -> { data, key, iv } {
        return Crypto.aesDecrypt(
            encrypted: data,
            key: key,
            iv: iv,
            mode: cMode,
            padding: cPadding,
        );
    }

    cEncrypt := -> { data, key, iv } {
        return Crypto.aesEncrypt(
            input: data,
            key: key,
            iv: iv,
            mode: cMode,
            padding: cPadding,
        );
    }
}
