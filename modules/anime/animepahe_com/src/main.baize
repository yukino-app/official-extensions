import './config.baize' as config;

extractor := {
    defaultLocale: config.defaultLocale,
    search: -> terms, locale {
        resp := Http.request({
            method: 'get',
            url: config.getSearchApiUrl(terms),
            headers: config.defaultHeaders,
        });
        parsed := Convert.decodeJson(resp.body);
        
        return parsed.data.map(
            -> x : {
                title: x.title,
                url: config.getAnimeUrl(x.session),
                thumbnail: {
                    url: Url.ensure(x.poster),
                    headers: config.defaultHeaders,
                },
                locale: config.defaultLocale,
            }
        );
    },
    getInfo: -> url, locale {
        url = Url.ensure(url);
        slug := config.parseSlug(url);
        resp := Http.request({
            method: 'get',
            url: url,
            headers: config.defaultHeaders,
        });
        id := RegExp.new(r'\/a\/(\d+)').firstMatch(resp.body).group(1);
        document := HtmlElement.parse(resp.body);

        eResp := Http.request({
            method: 'get',
            url: config.getEpisodesApiUrl(slug),
            headers: config.defaultHeaders,
        });
        eParsed := Convert.decodeJson(eResp.body);
        eStart := eParsed.from;
        eTotal := eParsed.total;
        episodes := List.generate(eTotal, -> i {
            eNum := eStart + i;
            return {
                episode: String.from(eNum),
                url: config.getCustomEpisodeUrl(id, slug, eNum),
                locale: config.defaultLocale,
            };
        });

        return {
            title: document
                .querySelector('.anime-header .title-wrapper > h1 > span')
                .text
                .trim(),
            url: url,
            thumbnail: {
                url: Url.ensure(
                    document
                        .querySelector('.anime-header .anime-poster img')
                        .attributes['data-src']
                        .trim()
                ),
                headers: config.defaultHeaders,
            },
            episodes: episodes,
            locale: config.defaultLocale,
            availableLocales: [config.defaultLocale],
        };
    },
    getSource: -> url, locale {
        url = Url.ensure(url);

        if (config.isPlayUrl(url)) {
            uParsed := config.parsePlayUrl(url);
            resp := Http.request({
                method: 'get',
                url: url,
                headers: config.defaultHeaders,
            });
            id := RegExp.new.new(r'getUrls\((\d+)').firstMatch(resp.body).group(1);
            return _getSource(id, uParsed.episodeSlug);
        }

        uParsed := config.parseCustomEpisodeUrl(url);
        eNum := Number.from(uParsed.episode);
        eResp := Http.request({
            method: 'get',
            url: config.getEpisodesApiUrlFromNumber(uParsed.animeSlug, eNum),
            headers: config.defaultHeaders,
        });
        eParsed := Convert.decodeJson(eResp.body);
        eData := eParsed.data.find(-> x : x.episode == eNum);
        return _getSource(eData.animeId, eData.session);
    },
};

_getSource := -> id, slug {
    resp := Http.request({
        method: 'get',
        url: config.getStreamsApiUrl(id, slug),
        headers: config.defaultHeaders,
    });
    parsed := Convert.decodeJson(resp.body);
    
    streams := parsed.data.map(-> x {
        quality := Object.keys(x)[0];
        y := x[quality];
        embed := Url.ensure(y.kwik);
        parsedEmbedUrl := Url.parse(embed);
        eResp := Http.request({
            method: 'get',
            url: embed,
            headers: config.defaultHeaders,
        });
        m := RegExp.new(r`Plyr\|(.+?)['"]`)
            .firstMatch(eResp.body)
            .group(1)
            .split('|');

        return {
            url: '{}://{}-{}.{}.{}.{}/{}/{}/{}/{}.{}'.format(m.reversed()),
            headers: Object.apply(Object.clone(config.defaultHeaders), {
                Referer: parsedEmbedUrl.origin,
            }),
            quality: quality,
            locale: config.defaultLocale,
        };
    });

    return {
        streams: streams,
        subtitles: [],
    };
};
